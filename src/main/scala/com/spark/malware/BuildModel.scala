package com.spark.malware

import org.apache.spark.mllib.linalg.Vectors
import org.apache.spark.mllib.regression.LabeledPoint
import org.apache.spark.rdd.RDD

/**
  * Created by ram on 11/23/16.
  */
object BuildModel {

  var modelType = RunParameters.DEFAULT_FEATURE_SELECTION_METHOD

  def setModelType( model : String ) = {
    this.modelType = model
  }

  def train( records : RDD[(String, String)] ) = {

    if( this.modelType.equals(Constants.SUPPORT_VECTOR_MACHINE) ) {

    }

  }

  def getLabeledPoint( line : String ) = {
    val originalFeatureListWithLabel = line.split(",")
    val label = originalFeatureListWithLabel(originalFeatureListWithLabel.length-1)
    val featureList = originalFeatureListWithLabel diff List(originalFeatureListWithLabel(0), label)
    val vectorList = Vectors.dense(featureList.map(_.toDouble))
    val labeledPoint = new LabeledPoint(label.toDouble, vectorList)
    labeledPoint
  }

  def supportVectorMachine( records : RDD[(String,String)] ) = {


    // Load and parse the data file.
    val data = sc.textFile("/home/ram/Downloads/hw3datasetnew/glass.data")

    //get RDD[LabeledPoint]
    val parsedData = data.map( line => getLabeledPoint(line) )

    // Split data into training (60%) and test (40%).
    val Array(training, test) = parsedData.randomSplit(Array(0.6, 0.4))

    //Build Model
    val naiveBayesModel = NaiveBayes.train(training, lambda = 1.0, modelType = "multinomial")

    //predict label for test data
    val predictionAndLabel = test.map(p => (naiveBayesModel.predict(p.features), p.label))

    //compute accuracy
    val accuracyNaiveBayes = 1.0 * predictionAndLabel.filter(x => x._1 == x._2).count() / test.count()

    //set parameters for decision tree model
    val numClasses = 8
    val categoricalFeaturesInfo = Map[Int, Int]()
    val impurity = "gini"
    val maxDepth = 12
    val maxBins = 32

    // Train a DecisionTree model.
    val decisionTreeModel = DecisionTree.trainClassifier(training, numClasses, categoricalFeaturesInfo,
      impurity, maxDepth, maxBins)

    // predict class label for test instances
    val labelAndPreds = test.map { point =>
      val prediction = decisionTreeModel.predict(point.features)
      (point.label, prediction)
    }

    val accuracyDecisionTree = labelAndPreds.filter(r => r._1 == r._2).count().toDouble / test.count()

    //Results
    println( "Naive Bayes Model: Accuracy =		" + "%2.2f".format(accuracyNaiveBayes*100)+ " %")
    println( "Decision Tree Model: Accuracy =		" + "%2.2f".format(accuracyDecisionTree*100) + " %")
  }

}
